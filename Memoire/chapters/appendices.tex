%====================================================================
% Appendices - SecureIoT-VIF Community Edition
%====================================================================

\appendix

\chapter{Spécifications techniques détaillées}
\label{app:specifications}

\section{Architecture matérielle ESP32}

L'ESP32-WROOM-32 intègre un processeur dual-core Tensilica Xtensa LX6 32-bit cadencé à 240 MHz, offrant une puissance de calcul suffisante pour les opérations cryptographiques de base. Les spécifications détaillées incluent :

\subsection{Caractéristiques du processeur}

\begin{itemize}
    \item \textbf{Architecture :} Dual-core Tensilica Xtensa LX6 32-bit
    \item \textbf{Fréquence :} 240 MHz (configurable)
    \item \textbf{Mémoire RAM :} 520 KB SRAM interne
    \item \textbf{Mémoire Flash :} 4 MB SPI Flash externe
    \item \textbf{Cache :} 32 KB instruction cache, 32 KB data cache
    \item \textbf{Coprocesseur :} Ultra Low Power (ULP) co-processor
\end{itemize}

\subsection{Interfaces de communication}

\begin{itemize}
    \item \textbf{Wi-Fi :} 802.11 b/g/n/e/i (2.4 GHz)
    \item \textbf{Bluetooth :} v4.2 BR/EDR et BLE
    \item \textbf{GPIO :} 34 broches programmables
    \item \textbf{SPI :} 4 contrôleurs SPI
    \item \textbf{I2C :} 2 interfaces I2C
    \item \textbf{UART :} 3 interfaces UART
    \item \textbf{ADC :} 18 canaux 12-bit SAR ADC
\end{itemize}

\subsection{Capacités cryptographiques intégrées}

\begin{itemize}
    \item \textbf{Accélérateur AES :} AES-128, AES-192, AES-256
    \item \textbf{Accélérateur SHA :} SHA-1, SHA-256, SHA-384, SHA-512
    \item \textbf{Accélérateur RSA :} jusqu'à RSA-4096
    \item \textbf{Générateur RNG :} True Random Number Generator
    \item \textbf{Flash Encryption :} Chiffrement hardware du firmware
    \item \textbf{Secure Boot :} Démarrage sécurisé avec signatures digitales
\end{itemize}

\section{Implémentation mbedTLS}

La Community Edition utilise exclusivement les implémentations software de mbedTLS pour des raisons éducatives, permettant une compréhension claire des algorithmes sans dépendance aux accélérateurs matériels.

\subsection{Configuration mbedTLS utilisée}

\begin{lstlisting}[language=C, caption=Configuration mbedTLS Community]
// Configuration de base pour l'éducation
#define MBEDTLS_AES_C
#define MBEDTLS_SHA256_C  
#define MBEDTLS_MD_C
#define MBEDTLS_CIPHER_C
#define MBEDTLS_ENTROPY_C
#define MBEDTLS_CTR_DRBG_C

// Désactivation des accélérateurs hardware 
#undef MBEDTLS_AES_ALT
#undef MBEDTLS_SHA256_ALT

// Configuration pour contraintes mémoire
#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
#define MBEDTLS_PLATFORM_MEMORY
\end{lstlisting}

\subsection{Algorithmes implémentés}

\begin{table}[h!]
\centering
\caption{Algorithmes cryptographiques Community Edition}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Type} & \textbf{Algorithme} & \textbf{Usage} \\
\midrule
Chiffrement symétrique & AES-256-CBC & Chiffrement des données \\
Fonction de hachage & SHA-256 & Intégrité et signatures \\
HMAC & HMAC-SHA256 & Authentification de messages \\
Génération aléatoire & CTR\_DRBG & Génération de clés et nonces \\
Dérivation de clés & PBKDF2 & Dérivation sécurisée \\
\bottomrule
\end{tabular}
\end{table}

\section{Protocoles de communication}

\subsection{Format des messages de vérification}

\begin{lstlisting}[language=C, caption=Structure message de vérification]
typedef struct {
    uint32_t magic;           // 0xDEADBEEF
    uint32_t version;         // Version du protocole
    uint32_t timestamp;       // Horodatage Unix
    uint32_t firmware_size;   // Taille du firmware
    uint8_t  firmware_hash[32]; // SHA-256 du firmware
    uint8_t  hmac[32];        // HMAC du message
} verification_message_t;
\end{lstlisting}

\subsection{Séquence de vérification d'intégrité}

\begin{enumerate}
    \item \textbf{Initialisation :} Chargement des clés depuis NVS
    \item \textbf{Lecture firmware :} Lecture par blocs de 4KB
    \item \textbf{Calcul hash :} SHA-256 progressif
    \item \textbf{Vérification :} Comparaison avec hash de référence
    \item \textbf{Notification :} Envoi du résultat via UART/Wi-Fi
\end{enumerate}

\chapter{Tests de performance détaillés}
\label{app:performance}

\section{Méthodologie de mesure}

Les tests de performance ont été réalisés dans les conditions suivantes :
- ESP32 cadencé à 240 MHz
- Température ambiante de 25°C ± 2°C
- Alimentation stable 3.3V
- Firmware de test de 128KB

\subsection{Outils de mesure}

\begin{itemize}
    \item \textbf{Mesure temporelle :} esp\_timer\_get\_time() avec résolution microseconde
    \item \textbf{Consommation :} Nordic Power Profiler Kit II
    \item \textbf{Utilisation mémoire :} esp\_get\_free\_heap\_size()
    \item \textbf{Charge CPU :} Compteurs de cycles intégrés
\end{itemize}

\section{Résultats détaillés}

\subsection{Performance de vérification d'intégrité}

\begin{table}[h!]
\centering
\caption{Temps de vérification par taille de firmware}
\begin{tabular}{@{}lllll@{}}
\toprule
\textbf{Taille} & \textbf{Lecture} & \textbf{SHA-256} & \textbf{Vérification} & \textbf{Total} \\
\midrule
32KB  & 12ms & 18ms & 2ms & 32ms \\
64KB  & 23ms & 34ms & 2ms & 59ms \\
128KB & 45ms & 67ms & 2ms & 114ms \\
256KB & 89ms & 132ms & 2ms & 223ms \\
512KB & 178ms & 264ms & 2ms & 444ms \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Consommation énergétique}

\begin{table}[h!]
\centering
\caption{Profil de consommation durant la vérification}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Phase} & \textbf{Courant} & \textbf{Durée} & \textbf{Énergie} \\
\midrule
Repos & 0.8mA & - & - \\
Lecture Flash & 45mA & 45ms & 2.025mJ \\
Calcul SHA-256 & 78mA & 67ms & 5.226mJ \\
Vérification & 52mA & 2ms & 0.104mJ \\
\textbf{Total} & - & \textbf{114ms} & \textbf{7.355mJ} \\
\bottomrule
\end{tabular}
\end{table}

\chapter{Guide d'installation et configuration}
\label{app:installation}

\section{Prérequis système}

\subsection{Environnement de développement}

\begin{itemize}
    \item \textbf{ESP-IDF :} Version 4.4 ou supérieure
    \item \textbf{Python :} Version 3.6 ou supérieure
    \item \textbf{Git :} Pour le clonage du repository
    \item \textbf{Pilotes USB :} CP210x ou FTDI selon le board ESP32
\end{itemize}

\subsection{Matériel nécessaire}

\begin{itemize}
    \item ESP32-WROOM-32 DevKit V1 (\textasciitilde 5\textdollar)
    \item DHT22 ou DHT11 (\textasciitilde 3\textdollar)
    \item Câbles de connexion (3 unités)
    \item Breadboard (optionnel)
    \item Câble USB Type-A vers Micro-USB
\end{itemize}

\section{Installation étape par étape}

\subsection{Configuration de l'environnement ESP-IDF}

\begin{lstlisting}[language=bash, caption=Installation ESP-IDF Linux]
# Installation des dépendances
sudo apt-get install git wget flex bison gperf python3 \
python3-pip python3-setuptools cmake ninja-build ccache \
libffi-dev libssl-dev doxygen libusb-1.0-0

# Clonage ESP-IDF
git clone --recursive https://github.com/espressif/esp-idf.git
cd esp-idf
./install.sh esp32

# Configuration de l'environnement
. $HOME/esp-idf/export.sh
\end{lstlisting}

\subsection{Compilation et flashage}

\begin{lstlisting}[language=bash, caption=Compilation du projet]
# Clonage du projet Community
git clone <repository-url> secureiot-vif-community
cd secureiot-vif-community

# Configuration
idf.py set-target esp32
idf.py menuconfig  # Configuration optionnelle

# Compilation
idf.py build

# Flashage (adapter le port)
idf.py -p /dev/ttyUSB0 flash

# Monitoring
idf.py -p /dev/ttyUSB0 monitor
\end{lstlisting}

\section{Configuration avancée}

\subsection{Paramètres de sécurité}

\begin{lstlisting}[language=C, caption=Configuration sécurité Community]
// Configuration dans main/app_config.h
#define SECURITY_LEVEL_COMMUNITY    1
#define INTEGRITY_CHECK_INTERVAL    30000   // 30 secondes
#define ANOMALY_THRESHOLD_TEMP      10.0f   // Degrés Celsius
#define ANOMALY_THRESHOLD_HUMIDITY  25.0f   // Pourcentage
#define MAX_ANOMALY_COUNT          5       // Avant alarme
\end{lstlisting}

\subsection{Configuration réseau}

\begin{lstlisting}[language=C, caption=Configuration Wi-Fi]
// Configuration dans main/wifi_config.h
#define WIFI_SSID      "SecureIoT-Lab"
#define WIFI_PASS      "EducationalFramework2024"
#define WIFI_MAXIMUM_RETRY  5
#define WIFI_CONNECT_TIMEOUT  10000  // 10 secondes
\end{lstlisting}

\chapter{Exercices pédagogiques}
\label{app:exercises}

\section{Exercice 1 : Analyse de l'intégrité}

\subsection{Objectifs d'apprentissage}

\begin{itemize}
    \item Comprendre les mécanismes de hachage cryptographique
    \item Observer l'impact des modifications sur l'intégrité
    \item Analyser les temps de vérification en fonction de la taille
\end{itemize}

\subsection{Instructions}

\begin{enumerate}
    \item Compiler et flasher le firmware de base
    \item Observer les logs de vérification d'intégrité au démarrage
    \item Modifier une variable dans le firmware et recompiler
    \item Observer la détection de la modification
    \item Mesurer les temps de vérification pour différentes tailles
\end{enumerate}

\subsection{Questions de réflexion}

\begin{itemize}
    \item Pourquoi SHA-256 est-il approprié pour la vérification d'intégrité ?
    \item Quel est l'impact de la taille du firmware sur le temps de vérification ?
    \item Comment optimiser les performances tout en maintenant la sécurité ?
\end{itemize}

\section{Exercice 2 : Détection d'anomalies}

\subsection{Objectifs d'apprentissage}

\begin{itemize}
    \item Comprendre les seuils de détection d'anomalies
    \item Configurer et tester les paramètres de seuils
    \item Analyser les faux positifs et négatifs
\end{itemize}

\subsection{Scénario d'exercice}

\begin{enumerate}
    \item Connecter le capteur DHT22 selon le schéma fourni
    \item Configurer des seuils d'anomalie conservateurs
    \item Simuler des conditions anormales (chauffage/refroidissement)
    \item Observer les alertes générées
    \item Ajuster les seuils pour réduire les faux positifs
\end{enumerate}

\section{Exercice 3 : Architecture modulaire}

\subsection{Objectifs d'apprentissage}

\begin{itemize}
    \item Comprendre l'architecture modulaire du framework
    \item Développer un nouveau module de sécurité
    \item Intégrer le module dans l'architecture existante
\end{itemize}

\subsection{Développement pratique}

Créer un module de surveillance des tentatives d'accès :

\begin{lstlisting}[language=C, caption=Template nouveau module]
// components/access_monitor/access_monitor.c
#include "access_monitor.h"
#include "esp_log.h"

static const char* TAG = "ACCESS_MONITOR";

esp_err_t access_monitor_init(void) {
    ESP_LOGI(TAG, "Initializing access monitor...");
    // TODO: Implémentation étudiante
    return ESP_OK;
}

void access_monitor_log_attempt(const char* source) {
    ESP_LOGW(TAG, "Access attempt from: %s", source);
    // TODO: Logique de détection
}
\end{lstlisting}

\chapter{Comparaison avec solutions Enterprise}
\label{app:comparison}

\section{Analyse comparative des fonctionnalités}

\begin{longtable}{@{}p{4cm}p{3cm}p{3cm}p{4cm}@{}}
\caption{Comparaison Community vs Enterprise Edition} \\
\toprule
\textbf{Fonctionnalité} & \textbf{Community} & \textbf{Enterprise} & \textbf{Justification éducative} \\
\midrule
\endfirsthead
\multicolumn{4}{c}{\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
\toprule
\textbf{Fonctionnalité} & \textbf{Community} & \textbf{Enterprise} & \textbf{Justification éducative} \\
\midrule
\endhead
\midrule
\multicolumn{4}{r}{\textit{Continued on next page}} \\
\endfoot
\bottomrule
\endlastfoot
Cryptographie & Software (mbedTLS) & Hardware + Software & Compréhension des algorithmes \\
Vérification intégrité & Au démarrage & Temps réel & Simplicité d'implémentation \\
Détection anomalies & Seuils fixes & ML adaptatif & Concepts de base observables \\
Coût matériel & \textasciitilde 8\textdollar & \textasciitilde 50-200\textdollar & Accessibilité étudiante \\
Secure Boot & Désactivé & v2 activé & Focus sur concepts applicatifs \\
Flash Encryption & Désactivé & Activé & Éviter complexité excessive \\
Attestation & Locale & Distribuée & Limitation scope éducatif \\
Support & Communautaire & 24/7 SLA & Modèle éducatif approprié \\
Documentation & Éducative & Technique & Orientation pédagogique \\
Déploiement & Manuel & Automatisé & Apprentissage du processus \\
\end{longtable}

\section{Justification des choix Community}

\subsection{Cryptographie software vs hardware}

\textbf{Choix Community :} Utilisation exclusive de mbedTLS software

\textbf{Justification éducative :}
\begin{itemize}
    \item Observation directe du coût computationnel des algorithmes
    \item Possibilité de modification et d'expérimentation
    \item Compréhension des implémentations sans abstraction matérielle
    \item Portabilité vers d'autres plateformes éducatives
\end{itemize}

\subsection{Vérification au démarrage vs temps réel}

\textbf{Choix Community :} Vérification uniquement au boot

\textbf{Justification éducative :}
\begin{itemize}
    \item Concept d'intégrité clairement observable
    \item Implémentation simplifiée pour débutants
    \item Évite la complexité de la vérification continue
    \item Base solide pour progression vers concepts avancés
\end{itemize}

\section{Chemins de migration}

\subsection{De Community vers Enterprise}

\begin{enumerate}
    \item \textbf{Phase 1 :} Maîtrise des concepts Community
    \item \textbf{Phase 2 :} Activation progressive des fonctionnalités hardware
    \item \textbf{Phase 3 :} Intégration de la vérification temps réel
    \item \textbf{Phase 4 :} Déploiement des mécanismes avancés (ML, attestation)
    \item \textbf{Phase 5 :} Migration complète vers Enterprise avec support
\end{enumerate}

\subsection{Bénéfices de la progression}

\begin{itemize}
    \item Compréhension solide des fondements avant optimisation
    \item Appréciation de la valeur des améliorations Enterprise
    \item Capacité d'évaluation technique informée
    \item Réduction de la courbe d'apprentissage Enterprise
\end{itemize}