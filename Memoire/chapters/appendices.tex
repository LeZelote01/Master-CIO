%====================================================================
% Annexes - SecureIoT-VIF Community Edition
%====================================================================

\chapter{Annexes}
\label{chap:appendices}

\section{Code source principal SecureIoT-VIF Community}
\label{app:source-code}

Cette annexe pr√©sente les extraits de code source les plus significatifs de SecureIoT-VIF Community Edition.

\subsection{Configuration principale - app\_config.h}

\lstset{language=C}
\begin{lstlisting}[caption={Configuration principale SecureIoT-VIF Community Edition}]
/**
 * @file app_config.h
 * @brief Configuration globale du framework SecureIoT-VIF Community Edition
 */
#ifndef APP_CONFIG_H
#define APP_CONFIG_H

// ================================
// Configuration g√©n√©rale Community
// ================================
#define SECURE_IOT_VIF_VERSION "1.0.0-COMMUNITY"
#define SECURE_IOT_VIF_NAME "SecureIoT-VIF-Community"
#define SECURE_IOT_VIF_EDITION "Community Edition"

// ================================
// Configuration des t√¢ches FreeRTOS
// ================================
// T√¢che de monitoring de s√©curit√© (priorit√© r√©duite)
#define SECURITY_MONITOR_STACK_SIZE      (6144)    // R√©duit vs Enterprise
#define SECURITY_MONITOR_PRIORITY        (8)       // R√©duit vs Enterprise 
#define SECURITY_MONITOR_INTERVAL_MS     (10000)   // 10 secondes vs 5s

// T√¢che de gestion des capteurs
#define SENSOR_TASK_STACK_SIZE           (4096)
#define SENSOR_TASK_PRIORITY             (7)
#define SENSOR_READ_INTERVAL_MS          (5000)    // 5 secondes vs 2s

// ================================
// Configuration Crypto Community (basique)
// ================================
// Pas de configuration HSM/eFuse avanc√©e en Community
#define COMMUNITY_CRYPTO_BASIC_ONLY      (true)
#define COMMUNITY_SOFTWARE_CRYPTO        (true)
#define COMMUNITY_NO_HSM                 (true)

// Tailles des cl√©s basiques
#define BASIC_ECDSA_KEY_SIZE_BITS       (256)
#define BASIC_AES_KEY_SIZE_BITS         (128)     // AES-128 vs AES-256
#define BASIC_HMAC_KEY_SIZE_BYTES       (16)

// Configuration GPIO DHT22
#define DHT22_GPIO_PIN                  (4)
#define DHT22_POWER_GPIO                (5)

// Seuils d'anomalie (plus tol√©rants)
#define TEMP_ANOMALY_THRESHOLD          (10.0f)   // Plus large vs Enterprise
#define HUMIDITY_ANOMALY_THRESHOLD      (25.0f)   // Plus large vs Enterprise

#endif /* APP_CONFIG_H */
\end{lstlisting}

\subsection{Point d'entr√©e principal - main.c}

\begin{lstlisting}[caption={Fonction principale SecureIoT-VIF Community}]
/**
 * @brief Point d'entr√©e principal de l'application Community
 */
void app_main(void) {
    ESP_LOGI(TAG, "üöÄ === D√©marrage SecureIoT-VIF Community Edition ===");
    
    // Initialisation de la m√©moire NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Afficher les capacit√©s Community Edition
    ESP_LOGI(TAG, "üéì SecureIoT-VIF Community Edition:");
    ESP_LOGI(TAG, "  ‚úÖ Crypto de base pour √©ducation et recherche");
    ESP_LOGI(TAG, "  ‚úÖ V√©rification d'int√©grit√© au d√©marrage");
    ESP_LOGI(TAG, "  ‚úÖ D√©tection d'anomalies par seuils fixes");
    ESP_LOGI(TAG, "  ‚úÖ Interface capteurs DHT22 compl√®te");
    ESP_LOGI(TAG, "  üéØ Id√©al pour apprentissage et prototypage!");
    
    // Initialisation du syst√®me de s√©curit√© Community
    ret = init_security_system();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "üí• √âchec initialisation syst√®me Community - arr√™t");
        esp_restart();
    }
    
    // Initialisation des t√¢ches et timers
    ret = init_tasks_and_timers();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "üí• √âchec initialisation t√¢ches et timers - arr√™t");
        esp_restart();
    }
    
    ESP_LOGI(TAG, "üéâ === SecureIoT-VIF Community Edition Op√©rationnel ===");
}
\end{lstlisting}

\subsection{Crypto de base - crypto\_operations\_basic.c}

\begin{lstlisting}[caption={Op√©rations cryptographiques de base}]
/**
 * @brief Initialise le syst√®me cryptographique de base
 */
esp_err_t crypto_operations_basic_init(void) {
    if (crypto_initialized) {
        ESP_LOGW(TAG, "Crypto de base d√©j√† initialis√©");
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "üîê Initialisation crypto de base Community Edition");
    
    // Initialisation entropy (software uniquement)
    mbedtls_entropy_init(&entropy_ctx);
    mbedtls_ctr_drbg_init(&ctr_drbg_ctx);
    mbedtls_ecdsa_init(&ecdsa_ctx);
    
    // Seed du g√©n√©rateur al√©atoire
    const char *pers = "secureiot_vif_community";
    int mbedtls_ret = mbedtls_ctr_drbg_seed(&ctr_drbg_ctx, mbedtls_entropy_func, 
                                           &entropy_ctx, (const unsigned char *)pers, strlen(pers));
    if (mbedtls_ret != 0) {
        ESP_LOGE(TAG, "‚ùå √âchec seed g√©n√©rateur al√©atoire: -0x%04x", -mbedtls_ret);
        return ESP_FAIL;
    }
    
    crypto_initialized = true;
    ESP_LOGI(TAG, "‚úÖ Crypto de base Community initialis√©");
    ESP_LOGI(TAG, "üí° Version √©ducative - Crypto software seulement");
    
    return ESP_OK;
}

/**
 * @brief Calcule un hash SHA-256 (software)
 */
esp_err_t crypto_basic_sha256(const uint8_t *input, size_t input_len, uint8_t *output) {
    if (input == NULL || output == NULL || input_len == 0) {
        ESP_LOGE(TAG, "‚ùå Param√®tres invalides pour SHA-256");
        return ESP_ERR_INVALID_ARG;
    }
    
    mbedtls_sha256_context sha256_ctx;
    mbedtls_sha256_init(&sha256_ctx);
    
    int mbedtls_ret = mbedtls_sha256_starts_ret(&sha256_ctx, 0); // SHA-256
    if (mbedtls_ret != 0) {
        ESP_LOGE(TAG, "‚ùå √âchec initialisation SHA-256: -0x%04x", -mbedtls_ret);
        mbedtls_sha256_free(&sha256_ctx);
        return ESP_FAIL;
    }
    
    mbedtls_ret = mbedtls_sha256_update_ret(&sha256_ctx, input, input_len);
    mbedtls_ret = mbedtls_sha256_finish_ret(&sha256_ctx, output);
    mbedtls_sha256_free(&sha256_ctx);
    
    ESP_LOGD(TAG, "üîí SHA-256 calcul√© (software): %d bytes", input_len);
    return ESP_OK;
}
\end{lstlisting}

\subsection{Driver DHT22 - dht22\_driver.c}

\begin{lstlisting}[caption={Driver complet du capteur DHT22}]
/**
 * @brief Lit les donn√©es du capteur DHT22
 */
esp_err_t dht22_read_data(float *temperature, float *humidity) {
    if (!dht22_initialized) {
        ESP_LOGE(TAG, "‚ùå Driver DHT22 non initialis√©");
        return ESP_ERR_INVALID_STATE;
    }
    
    uint8_t data[5] = {0};
    uint32_t pulse_durations[40];
    
    // D√©sactiver les interruptions pour un timing pr√©cis
    portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;
    portENTER_CRITICAL(&mux);
    
    // Phase 1: Signal de d√©marrage
    gpio_set_level(DHT22_GPIO_PIN, 0);  // LOW pendant 1ms
    ets_delay_us(1000);
    gpio_set_level(DHT22_GPIO_PIN, 1);  // HIGH pendant 30¬µs
    ets_delay_us(30);
    
    // Phase 2: Lecture des 40 bits de donn√©es
    for (int i = 0; i < 40; i++) {
        // Chaque bit commence par un LOW de 50¬µs
        uint32_t low_duration = dht22_read_pulse(0, 70);
        if (low_duration == 0) {
            portEXIT_CRITICAL(&mux);
            dht22_stats.failed_reads++;
            return ESP_ERR_TIMEOUT;
        }
        
        // Puis un HIGH dont la dur√©e d√©termine le bit (26-28¬µs=0, 70¬µs=1)
        uint32_t high_duration = dht22_read_pulse(1, 80);
        pulse_durations[i] = high_duration;
    }
    
    portEXIT_CRITICAL(&mux);
    
    // Phase 3: D√©codage des donn√©es
    for (int i = 0; i < 40; i++) {
        int byte_idx = i / 8;
        int bit_idx = 7 - (i % 8);
        
        // Si l'impulsion HIGH > 40¬µs, c'est un bit 1
        if (pulse_durations[i] > 40) {
            data[byte_idx] |= (1 << bit_idx);
        }
    }
    
    // Phase 4: V√©rification du checksum
    uint8_t checksum = data[0] + data[1] + data[2] + data[3];
    if (checksum != data[4]) {
        dht22_stats.checksum_errors++;
        return ESP_ERR_INVALID_CRC;
    }
    
    // Phase 5: Conversion des donn√©es
    uint16_t humidity_raw = (data[0] << 8) | data[1];
    *humidity = (float)humidity_raw / 10.0f;
    
    uint16_t temperature_raw = (data[2] << 8) | data[3];
    if (temperature_raw & 0x8000) {
        temperature_raw &= 0x7FFF;
        *temperature = -((float)temperature_raw / 10.0f);
    } else {
        *temperature = (float)temperature_raw / 10.0f;
    }
    
    dht22_stats.successful_reads++;
    return ESP_OK;
}
\end{lstlisting}

\section{Sch√©mas de d√©ploiement √©ducatif}
\label{app:deployment}

\subsection{Architecture mat√©rielle minimale}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.8]
        % ESP32
        \draw[thick] (0,0) rectangle (4,2);
        \node at (2,1) {ESP32-WROOM-32};
        
        % DHT22
        \draw[thick] (6,0) rectangle (8,1.5);
        \node at (7,0.75) {DHT22};
        
        % Connexions
        \draw[thick] (4,1) -- (6,0.75);
        \node at (5,1.2) {GPIO};
        
        % Alimentation
        \draw[thick] (1,2) -- (1,3);
        \node at (1.5,3.2) {USB 5V};
        
        % PC
        \draw[thick] (-2,-1) rectangle (2,-0.5);
        \node at (0,-0.75) {Ordinateur de d√©veloppement};
        
        % Connexion USB
        \draw[thick] (0,0) -- (0,-0.5);
        \node at (-1,0) {USB};
        
    \end{tikzpicture}
    \caption{Architecture mat√©rielle Community Edition}
    \label{fig:hardware-architecture-community}
\end{figure}

\subsection{Diagramme de flux √©ducatif}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=0.7]
        % Bo√Ætes
        \draw[thick] (0,6) rectangle (3,7) node[midway] {Installation};
        \draw[thick] (0,4.5) rectangle (3,5.5) node[midway] {Configuration};
        \draw[thick] (0,3) rectangle (3,4) node[midway] {Exercices guid√©s};
        \draw[thick] (0,1.5) rectangle (3,2.5) node[midway] {Exp√©rimentation};
        \draw[thick] (0,0) rectangle (3,1) node[midway] {Projet personnel};
        
        % Fl√®ches
        \draw[thick,->] (1.5,6) -- (1.5,5.5);
        \draw[thick,->] (1.5,4.5) -- (1.5,4);
        \draw[thick,->] (1.5,3) -- (1.5,2.5);
        \draw[thick,->] (1.5,1.5) -- (1.5,1);
        
        % Temps
        \node at (4,6.5) {30 min};
        \node at (4,5) {1 heure};
        \node at (4,3.5) {4-6 heures};
        \node at (4,2) {2-4 heures};
        \node at (4,0.5) {Variable};
        
    \end{tikzpicture}
    \caption{Flux d'apprentissage recommand√©}
    \label{fig:learning-flow}
\end{figure}

\section{R√©sultats d√©taill√©s des tests}
\label{app:detailed-results}

\subsection{M√©triques de performance compl√®tes}

\begin{table}[h]
\centering
\caption{R√©sultats d√©taill√©s des tests de performance}
\label{tab:detailed-performance}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Test} & \textbf{Min (ms)} & \textbf{Max (ms)} & \textbf{Moyenne (ms)} & \textbf{√âcart-type} \\
\hline
SHA-256 (4KB) & 2.1 & 3.8 & 2.8 & 0.4 \\
ECDSA Sign & 45.2 & 67.3 & 52.1 & 5.8 \\
ECDSA Verify & 38.7 & 55.4 & 44.2 & 4.3 \\
Block Verification & 2.3 & 4.1 & 2.9 & 0.5 \\
Anomaly Detection & 12.4 & 18.7 & 15.1 & 2.1 \\
Random Generation (32B) & 0.9 & 1.6 & 1.2 & 0.2 \\
\hline
\end{tabular}
\end{table}

\subsection{Analyse statistique des faux positifs}

\begin{table}[h]
\centering
\caption{Distribution des faux positifs par cause}
\label{tab:false-positive-analysis}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Cause} & \textbf{Occurrences} & \textbf{Pourcentage} & \textbf{Gravit√©} \\
\hline
Pics CPU temporaires & 15 & 34.9\% & Faible \\
Variations temp√©rature & 10 & 23.3\% & Faible \\
Interf√©rences Wi-Fi & 8 & 18.6\% & Moyenne \\
Fragmentation m√©moire & 6 & 14.0\% & Faible \\
Autres causes & 4 & 9.3\% & Variable \\
\hline
\textbf{Total} & \textbf{43} & \textbf{100\%} & \\
\hline
\end{tabular}
\end{table}

\section{Guide d'installation d√©taill√©}
\label{app:installation-guide}

\subsection{Pr√©requis syst√®me}

\textbf{Mat√©riel requis :}
\begin{itemize}
    \item ESP32-WROOM-32 DevKit V1 (~5\$)
    \item DHT22 ou DHT11 (~3\$)
    \item Breadboard et c√¢bles jumper (fourniture de base)
    \item C√¢ble USB micro-B vers USB-A
    \item Ordinateur avec port USB libre
\end{itemize}

\textbf{Logiciels requis :}
\begin{itemize}
    \item ESP-IDF v4.4+ (gratuit)
    \item Python 3.7+ (g√©n√©ralement pr√©install√©)
    \item Pilotes USB-s√©rie (CP210x ou FTDI)
    \item Terminal s√©rie (int√©gr√© ESP-IDF)
\end{itemize}

\subsection{Proc√©dure d'installation √©tape par √©tape}

\textbf{√âtape 1 : Installation ESP-IDF}
\begin{enumerate}
    \item T√©l√©charger ESP-IDF depuis le site officiel Espressif
    \item Suivre le guide d'installation pour votre OS
    \item V√©rifier l'installation avec \texttt{idf.py --version}
\end{enumerate}

\textbf{√âtape 2 : Configuration mat√©rielle}
\begin{enumerate}
    \item Connecter DHT22 : VCC ‚Üí 3.3V, GND ‚Üí GND, Data ‚Üí GPIO4
    \item V√©rifier les connexions avec un multim√®tre si disponible
    \item Connecter ESP32 au PC via USB
\end{enumerate}

\textbf{√âtape 3 : Compilation et flash}
\begin{enumerate}
    \item Cloner le repository SecureIoT-VIF Community
    \item \texttt{cd secureiot-vif-community}
    \item \texttt{idf.py build}
    \item \texttt{idf.py -p /dev/ttyUSB0 flash monitor}
\end{enumerate}

\section{Exercices pratiques}
\label{app:exercises}

\subsection{Exercice 1 : Configuration de base}

\textbf{Objectif :} Installer et configurer SecureIoT-VIF Community Edition

\textbf{Pr√©requis :} Installation ESP-IDF compl√®te

\textbf{Dur√©e estim√©e :} 45 minutes

\textbf{Instructions :}
\begin{enumerate}
    \item Suivre le guide d'installation (Annexe \ref{app:installation-guide})
    \item Compiler et flasher le firmware de base
    \item Observer les logs de d√©marrage s√©curis√©
    \item Identifier les messages de v√©rification d'int√©grit√©
    \item Documenter les temps de d√©marrage mesur√©s
\end{enumerate}

\textbf{Questions de r√©flexion :}
\begin{itemize}
    \item Quelles sont les √©tapes de la cha√Æne de confiance observ√©es ?
    \item Quel est l'impact du framework sur le temps de d√©marrage ?
    \item Comment les cl√©s cryptographiques sont-elles g√©n√©r√©es ?
\end{itemize}

\subsection{Exercice 2 : Manipulation des seuils}

\textbf{Objectif :} Comprendre la d√©tection d'anomalies par seuils fixes

\textbf{Pr√©requis :} Exercice 1 compl√©t√© avec succ√®s

\textbf{Dur√©e estim√©e :} 90 minutes

\textbf{Instructions :}
\begin{enumerate}
    \item Modifier les seuils dans \texttt{secureiot\_config.h}
    \item Recompiler et reflasher
    \item Simuler des conditions anormales :
    \begin{itemize}
        \item Chauffer l'ESP32 (s√®che-cheveux) pour trigger le seuil temp√©rature
        \item Lancer des boucles intensives pour surcharger le CPU
        \item Allouer de la m√©moire pour trigger le seuil m√©moire
    \end{itemize}
    \item Observer et analyser les alertes g√©n√©r√©es
    \item Tester diff√©rentes valeurs de seuils
\end{enumerate}

\textbf{Questions de r√©flexion :}
\begin{itemize}
    \item Comment choisir des seuils appropri√©s ?
    \item Quels sont les avantages et inconv√©nients des seuils fixes ?
    \item Comment r√©duire les faux positifs ?
\end{itemize}

\subsection{Exercice 3 : Simulation d'attaques}

\textbf{Objectif :} Comprendre la d√©tection de modifications de firmware

\textbf{Pr√©requis :} Exercices 1 et 2 compl√©t√©s

\textbf{Dur√©e estim√©e :} 2 heures

\textbf{Instructions :}
\begin{enumerate}
    \item Calculer le hash initial du firmware avec l'outil fourni
    \item Modifier artificiellement quelques bytes dans la flash
    \item Observer la d√©tection lors de la v√©rification p√©riodique
    \item Analyser les logs de d√©tection d'int√©grit√©
    \item Restaurer le firmware original
    \item R√©p√©ter avec diff√©rents types de modifications
\end{enumerate}

\textbf{Attaques √† simuler :}
\begin{itemize}
    \item Modification d'un seul byte
    \item Modification de plusieurs bytes cons√©cutifs
    \item Modification dans diff√©rentes sections (code, donn√©es, config)
    \item Injection de code simple (NOP slides)
\end{itemize}

\section{Ressources compl√©mentaires}
\label{app:resources}

\subsection{Liens utiles}

\textbf{Documentation officielle :}
\begin{itemize}
    \item ESP-IDF Programming Guide : \url{https://docs.espressif.com/projects/esp-idf/}
    \item mbedTLS Documentation : \url{https://tls.mbed.org/}
    \item FreeRTOS Reference : \url{https://freertos.org/Documentation/}
\end{itemize}

\textbf{Communaut√©s et forums :}
\begin{itemize}
    \item ESP32 Community Forum : \url{https://esp32.com/}
    \item Reddit r/esp32 : \url{https://reddit.com/r/esp32}
    \item Stack Overflow ESP32 Tag : \url{https://stackoverflow.com/questions/tagged/esp32}
\end{itemize}

\subsection{Bibliographie sp√©cialis√©e}

Pour approfondir les concepts abord√©s dans SecureIoT-VIF Community Edition, nous recommandons la lecture des ouvrages et articles suivants :

\textbf{S√©curit√© IoT g√©n√©rale :}
\begin{itemize}
    \item "IoT Penetration Testing Cookbook" par Aaron Guzman
    \item "Practical IoT Hacking" par Fotios Chantzis
    \item "Building Secure Firmware" par Kai Michaelis
\end{itemize}

\textbf{Cryptographie embarqu√©e :}
\begin{itemize}
    \item "A Graduate Course in Applied Cryptography" par Dan Boneh
    \item "Embedded Security in Cars" par Lemke, Paar, Wolf
    \item Publications r√©centes sur la cryptographie l√©g√®re et post-quantique
\end{itemize}

\section{Licence et contribution}
\label{app:license}

\subsection{Licence d'utilisation}

SecureIoT-VIF Community Edition est distribu√© sous licence MIT, permettant :
\begin{itemize}
    \item Utilisation libre √† des fins √©ducatives et de recherche
    \item Modification et redistribution avec attribution
    \item Utilisation commerciale avec les restrictions appropri√©es
    \item Contribution communautaire encourag√©e
\end{itemize}

\subsection{Comment contribuer}

Les contributions au projet SecureIoT-VIF Community Edition sont les bienvenues :

\textbf{Types de contributions appr√©ci√©es :}
\begin{itemize}
    \item Corrections de bugs et am√©liorations du code
    \item Nouveaux exercices p√©dagogiques et sc√©narios
    \item Traductions de la documentation
    \item Portage vers d'autres plateformes (Arduino, Raspberry Pi)
    \item Am√©lioration de la documentation utilisateur
\end{itemize}

\textbf{Processus de contribution :}
\begin{enumerate}
    \item Fork du repository principal
    \item Cr√©ation d'une branche d√©di√©e pour la fonctionnalit√©
    \item D√©veloppement avec tests appropri√©s
    \item Documentation des modifications
    \item Pull request avec description d√©taill√©e
\end{enumerate}

Cette approche collaborative assure l'√©volution continue du framework pour b√©n√©ficier √† toute la communaut√© √©ducative en s√©curit√© IoT.