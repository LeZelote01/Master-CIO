%====================================================================
% Appendices - SecureIoT-VIF Community Edition
%====================================================================

\appendix

\chapter{Extraits de code principaux}
\label{app:code}

Cette appendice presente les extraits de code les plus representatifs du framework SecureIoT-VIF Community Edition, mettant en evidence l'approche educative et la simplicite de mise en œuvre.

\section{Code principal du framework}

\subsection{Point d'entree principal (main.c)}

Le point d'entree principal illustre l'architecture modulaire du framework :

\begin{lstlisting}[language=C, caption={Structure principale du framework - main.c}, label=lst:main-structure]
/**
 * @file main.c
 * @brief Point d'entree principal du framework SecureIoT-VIF Community Edition
 * Version simplifiee avec fonctionnalites de base pour education et recherche.
 */
#include "app_config.h"
#include "crypto_operations_basic.h"  // Version simplifiee
#include "integrity_checker.h"
#include "sensor_manager.h"
#include "anomaly_detector.h"
#include "incident_manager.h"

static const char *TAG = "SECURE_IOT_VIF_COMMUNITY";

// Handles des taches principales educatives
static TaskHandle_t security_monitor_task_handle = NULL;
static TaskHandle_t sensor_task_handle = NULL;

// Fonction principale d'initialisation educative
void app_main(void) {
    ESP_LOGI(TAG, "SecureIoT-VIF Community Edition - Demarrage");
    
    // Initialisation des composants de base
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Initialisation des modules de securite educatifs
    init_crypto_operations_basic();
    init_integrity_checker();
    init_sensor_manager();
    init_anomaly_detector();
    init_incident_manager();
    
    ESP_LOGI(TAG, "Framework initialise - Mode educatif actif");
}
\end{lstlisting}

\subsection{Verification d'integrite simplifiee}

Le module de verification d'integrite utilise des mecanismes de base comprehensibles :

\begin{lstlisting}[language=C, caption={Module de verification d'integrite - integrity\_checker.c}, label=lst:integrity-checker]
/**
 * @file integrity_checker.c
 * @brief Verificateur d'integrite educatif avec mecanismes de base
 */

// Structure de donnees educative pour IVM
typedef struct {
    uint32_t firmware_size;
    uint8_t expected_hash[32];  // SHA-256 simplifie
    uint32_t boot_count;
    bool integrity_status;
    char last_check_time[32];
} ivm_data_basic_t;

// Fonction de verification principale educative
esp_err_t check_firmware_integrity_basic(void) {
    ESP_LOGI(TAG, "Debut verification integrite - Mode educatif");
    
    const esp_partition_t* app_partition = esp_ota_get_running_partition();
    if (!app_partition) {
        ESP_LOGE(TAG, "Impossible d'obtenir la partition active");
        return ESP_FAIL;
    }
    
    // Calcul du hash simplifie pour education
    uint8_t calculated_hash[32];
    esp_err_t ret = calculate_partition_hash_basic(app_partition, calculated_hash);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Erreur calcul hash: %s", esp_err_to_name(ret));
        return ret;
    }
    
    // Comparaison avec reference stockee
    if (memcmp(calculated_hash, ivm_data.expected_hash, 32) == 0) {
        ESP_LOGI(TAG, "Integrite verifiee - Firmware sain");
        return ESP_OK;
    } else {
        ESP_LOGW(TAG, "Integrite compromise - Firmware modifie");
        trigger_security_incident_basic("INTEGRITY_VIOLATION");
        return ESP_FAIL;
    }
}

// Calcul de hash \'educatif simplifi\'e
static esp_err_t calculate_partition_hash_basic(const esp_partition_t* partition, 
                                               uint8_t* hash_output) {
    mbedtls_sha256_context sha256_ctx;
    mbedtls_sha256_init(&sha256_ctx);
    mbedtls_sha256_starts(&sha256_ctx, 0);
    
    uint8_t buffer[1024];
    size_t bytes_read = 0;
    
    for (size_t offset = 0; offset < partition->size; offset += sizeof(buffer)) {
        size_t to_read = MIN(sizeof(buffer), partition->size - offset);
        
        esp_err_t ret = esp_partition_read(partition, offset, buffer, to_read);
        if (ret != ESP_OK) {
            mbedtls_sha256_free(&sha256_ctx);
            return ret;
        }
        
        mbedtls_sha256_update(&sha256_ctx, buffer, to_read);
        bytes_read += to_read;
    }
    
    mbedtls_sha256_finish(&sha256_ctx, hash_output);
    mbedtls_sha256_free(&sha256_ctx);
    
    ESP_LOGI(TAG, "Hash calcule pour %zu bytes", bytes_read);
    return ESP_OK;
}
\end{lstlisting}

\section{Detection d'anomalies par seuils fixes}

\subsection{Algorithme de detection educatif}

Le systeme de detection d'anomalies utilise des seuils fixes configurables :

\begin{lstlisting}[language=C, caption={Detecteur d'anomalies educatif - anomaly\_detector.c}, label=lst:anomaly-detector]
/**
 * @file anomaly_detector.c  
 * @brief Detecteur d'anomalies avec seuils fixes pour education
 */

// Configuration des seuils educatifs
typedef struct {
    uint8_t cpu_threshold_percent;      // Seuil CPU (ex: 80%)
    uint32_t memory_threshold_kb;       // Seuil memoire libre (ex: 50KB)
    float temperature_threshold_c;      // Seuil temperature (ex: 45C)
    uint32_t network_threshold_bps;     // Seuil reseau (ex: 1000 bps)
    bool thresholds_active;
} anomaly_thresholds_t;

static anomaly_thresholds_t edu_thresholds = {
    .cpu_threshold_percent = 80,
    .memory_threshold_kb = 50,
    .temperature_threshold_c = 45.0,
    .network_threshold_bps = 1000,
    .thresholds_active = true
};

// Fonction principale de detection educative
esp_err_t detect_system_anomalies_basic(void) {
    ESP_LOGI(TAG, "Analyse anomalies - Seuils fixes educatifs");
    
    system_metrics_t current_metrics;
    esp_err_t ret = collect_system_metrics_basic(&current_metrics);
    if (ret != ESP_OK) {
        return ret;
    }
    
    bool anomaly_detected = false;
    char anomaly_details[256] = {0};
    
    // Verification CPU
    if (current_metrics.cpu_usage > edu_thresholds.cpu_threshold_percent) {
        anomaly_detected = true;
        snprintf(anomaly_details, sizeof(anomaly_details), 
                 "CPU surcharge: %d%% > %d%%", 
                 current_metrics.cpu_usage, edu_thresholds.cpu_threshold_percent);
        ESP_LOGW(TAG, "%s", anomaly_details);
    }
    
    // Verification memoire
    if (current_metrics.free_memory_kb < edu_thresholds.memory_threshold_kb) {
        anomaly_detected = true;
        snprintf(anomaly_details + strlen(anomaly_details), 
                 sizeof(anomaly_details) - strlen(anomaly_details),
                 "%sMemoire faible: %luKB < %luKB", 
                 strlen(anomaly_details) > 0 ? "; " : "",
                 current_metrics.free_memory_kb, edu_thresholds.memory_threshold_kb);
        ESP_LOGW(TAG, "Memoire critique: %lu KB disponible", current_metrics.free_memory_kb);
    }
    
    // Verification temperature (capteur educatif)
    if (current_metrics.temperature_c > edu_thresholds.temperature_threshold_c) {
        anomaly_detected = true;
        snprintf(anomaly_details + strlen(anomaly_details),
                 sizeof(anomaly_details) - strlen(anomaly_details),
                 "%sTemperature elevee: %.1fC > %.1fC",
                 strlen(anomaly_details) > 0 ? "; " : "",
                 current_metrics.temperature_c, edu_thresholds.temperature_threshold_c);
        ESP_LOGW(TAG, "Surchauffe detectee: %.1fC", current_metrics.temperature_c);
    }
    
    if (anomaly_detected) {
        trigger_security_incident_basic("BEHAVIORAL_ANOMALY");
        ESP_LOGW(TAG, "Anomalie systeme: %s", anomaly_details);
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "Systeme normal - Aucune anomalie detectee");
    return ESP_OK;
}
\end{lstlisting}

\section{Interface capteur educative}

\subsection{Gestionnaire de capteur DHT22}

L'interface capteur utilise le DHT22 accessible pour la temperature et humidite :

\begin{lstlisting}[language=C, caption={Interface capteur educative - sensor\_manager.c}, label=lst:sensor-manager]
/**
 * @file sensor_manager.c
 * @brief Gestionnaire de capteurs educatif - DHT22 pour temperature/humidite  
 */

// Configuration educative du capteur DHT22
#define DHT22_GPIO_PIN GPIO_NUM_4
#define SENSOR_READ_INTERVAL_MS 30000  // 30 secondes pour observation

typedef struct {
    float temperature_c;
    float humidity_percent;
    uint32_t timestamp;
    bool data_valid;
} sensor_reading_t;

static sensor_reading_t last_reading = {0};

// Lecture educative du capteur DHT22
esp_err_t read_dht22_sensor_basic(sensor_reading_t* reading) {
    ESP_LOGI(TAG, "Lecture capteur DHT22 - Mode educatif");
    
    // Configuration GPIO pour DHT22
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << DHT22_GPIO_PIN),
        .mode = GPIO_MODE_OUTPUT_OD,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&io_conf);
    
    // Sequence de demarrage DHT22 simplifiee pour education
    gpio_set_level(DHT22_GPIO_PIN, 0);
    vTaskDelay(pdMS_TO_TICKS(20));  // Signal de demarrage 20ms
    
    gpio_set_level(DHT22_GPIO_PIN, 1);
    gpio_set_direction(DHT22_GPIO_PIN, GPIO_MODE_INPUT);
    
    // Attente reponse du capteur (version simplifiee)
    uint32_t timeout = 100;
    while (gpio_get_level(DHT22_GPIO_PIN) == 1 && timeout--) {
        ets_delay_us(1);
    }
    
    if (timeout == 0) {
        ESP_LOGE(TAG, "DHT22 timeout - Capteur non detecte");
        reading->data_valid = false;
        return ESP_FAIL;
    }
    
    // Lecture des donnees (implementation simplifiee)
    uint8_t data[5] = {0};
    esp_err_t ret = read_dht22_data_basic(data);
    
    if (ret == ESP_OK) {
        // Calcul temperature et humidite (format DHT22)
        uint16_t humidity_raw = (data[0] << 8) | data[1];
        uint16_t temperature_raw = (data[2] << 8) | data[3];
        
        reading->humidity_percent = humidity_raw / 10.0;
        reading->temperature_c = temperature_raw / 10.0;
        reading->timestamp = xTaskGetTickCount();
        reading->data_valid = true;
        
        ESP_LOGI(TAG, "DHT22: %.1fC, %.1f%% humidite", 
                 reading->temperature_c, reading->humidity_percent);
        
        last_reading = *reading;
        return ESP_OK;
    }
    
    reading->data_valid = false;
    return ESP_FAIL;
}
\end{lstlisting}

\section{Configuration educative}

\subsection{Parametres du framework}

La configuration educative privilegie la simplicite et l'observabilite :

\begin{lstlisting}[language=C, caption={Configuration educative - app\_config.h}, label=lst:app-config]
/**
 * @file app_config.h
 * @brief Configuration du framework SecureIoT-VIF Community Edition
 */

#ifndef APP_CONFIG_H
#define APP_CONFIG_H

// Configuration educative generale
#define SECUREIOT_VERSION_MAJOR 1
#define SECUREIOT_VERSION_MINOR 0  
#define SECUREIOT_VERSION_PATCH 0
#define SECUREIOT_EDITION "Community"

// Parametres de securite educatifs
#define INTEGRITY_CHECK_INTERVAL_SEC 300    // 5 minutes pour observation
#define ANOMALY_CHECK_INTERVAL_SEC 30       // 30 secondes pour apprentissage
#define HEARTBEAT_INTERVAL_SEC 60           // 1 minute de monitoring

// Seuils de detection educatifs configurables
#define DEFAULT_CPU_THRESHOLD_PERCENT 80    // Seuil CPU accessible
#define DEFAULT_MEMORY_THRESHOLD_KB 50      // Seuil memoire observable  
#define DEFAULT_TEMP_THRESHOLD_C 45.0       // Seuil temperature sûr
#define DEFAULT_NETWORK_THRESHOLD_BPS 1000  // Seuil reseau educatif

// Configuration materielle educative
#define LED_STATUS_PIN GPIO_NUM_2           // LED integree ESP32
#define BUTTON_PIN GPIO_NUM_0               // Bouton BOOT pour tests
#define DHT22_SENSOR_PIN GPIO_NUM_4         // Capteur DHT22 standard

// Mode debogage educatif active
#define EDUCATIONAL_DEBUG_MODE 1
#define VERBOSE_LOGGING 1
#define SECURITY_ALERTS_CONSOLE 1

// Limites educatives pour experimentation sûre
#define MAX_INCIDENT_LOG_ENTRIES 50
#define MAX_SENSOR_READINGS_BUFFER 100
#define MAX_ANOMALY_HISTORY 20

#endif // APP_CONFIG_H
\end{lstlisting}

Cette appendice illustre l'approche educative du framework SecureIoT-VIF Community Edition, privilegiant la clarte du code, la simplicite de configuration, et l'observabilite des mecanismes de securite pour faciliter l'apprentissage et l'experimentation pedagogique.