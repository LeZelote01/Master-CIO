#!/usr/bin/env python3
"""
Outil de flash et configuration pour SecureIoT-VIF Community Edition
Version simplifi√©e pour l'apprentissage et l'√©ducation
"""

import os
import sys
import subprocess
import argparse
import json
from pathlib import Path
import time

def run_command(cmd, check=True):
    """Ex√©cute une commande et affiche le r√©sultat"""
    print(f"üîß Ex√©cution: {cmd}")
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    
    if result.stdout:
        print(result.stdout)
    if result.stderr and result.returncode != 0:
        print(f"‚ùå Erreur: {result.stderr}")
    
    if check and result.returncode != 0:
        sys.exit(1)
    
    return result

def check_environment():
    """V√©rifie l'environnement ESP-IDF et version Community"""
    print("üîç V√©rification environnement ESP-IDF Community...")
    
    # V√©rifier ESP-IDF
    result = run_command("idf.py --version", check=False)
    if result.returncode != 0:
        print("‚ùå ESP-IDF non trouv√©. Veuillez configurer votre environnement.")
        print("üí° Ex√©cutez: source $HOME/esp/esp-idf/export.sh")
        sys.exit(1)
    
    print("‚úÖ ESP-IDF configur√© correctement")
    
    # V√©rifier version SecureIoT-VIF Community
    if os.path.exists("main/app_config.h"):
        with open("main/app_config.h", "r") as f:
            content = f.read()
            if "1.0.0-COMMUNITY" in content:
                print("‚úÖ SecureIoT-VIF Community Edition d√©tect√©e")
            elif "2.0.0-ESP32-CRYPTO" in content:
                print("‚ö†Ô∏è SecureIoT-VIF Enterprise d√©tect√©e - Utilisez l'outil Enterprise")
                print("üí° Vous √™tes dans le mauvais r√©pertoire pour Community")
            else:
                print("‚ùì Version SecureIoT-VIF non identifi√©e")

def configure_project(args):
    """Configure le projet Community avec optimisations √©ducatives"""
    print("‚öôÔ∏è Configuration SecureIoT-VIF Community Edition...")
    
    if args.auto_config:
        # Configuration automatique Community
        config = {
            # Configuration Community Edition (√©ducative)
            "CONFIG_SECURE_IOT_COMMUNITY_EDITION": "y",
            "CONFIG_SECURE_IOT_BASIC_CRYPTO_ONLY": "y",
            "CONFIG_SECURE_IOT_SECURITY_LEVEL": "2",
            
            # Configuration capteurs (DHT22 seulement)
            "CONFIG_SECURE_IOT_DHT22_GPIO": "4",
            "CONFIG_SECURE_IOT_DHT22_POWER_GPIO": "5",
            
            # Intervalles Community (moins fr√©quents)
            "CONFIG_SECURE_IOT_INTEGRITY_CHECK_INTERVAL": "300",
            "CONFIG_SECURE_IOT_SENSOR_READ_INTERVAL": "5",
            
            # Crypto Community (software seulement)
            "CONFIG_MBEDTLS_HARDWARE_AES": "n",
            "CONFIG_MBEDTLS_HARDWARE_SHA": "n", 
            "CONFIG_MBEDTLS_ECDSA_C": "y",
            "CONFIG_MBEDTLS_ECP_C": "y",
            
            # Configuration ESP32 Community (basique)
            "CONFIG_ESP32_DEFAULT_CPU_FREQ_160": "y",
            "CONFIG_ESP32_ENABLE_COREDUMP": "n",
            "CONFIG_ESP32_PANIC_HANDLER_REBOOT": "y",
            
            # D√©sactiver fonctionnalit√©s Enterprise
            "CONFIG_SECURE_BOOT": "n",
            "CONFIG_SECURE_FLASH_ENC_ENABLED": "n"
        }
        
        # √âcrire la configuration Community
        print("üìù Application configuration Community...")
        with open("sdkconfig", "w") as f:
            for key, value in config.items():
                f.write(f"{key}={value}\n")
        
        print("‚úÖ Configuration Community appliqu√©e")
        
        # Afficher les fonctionnalit√©s Community
        print("üéì Fonctionnalit√©s Community activ√©es:")
        print("  ‚úÖ Crypto de base (software mbedTLS)")
        print("  ‚úÖ V√©rification int√©grit√© au boot seulement")
        print("  ‚úÖ D√©tection anomalies par seuils fixes")
        print("  ‚úÖ Interface capteurs DHT22 compl√®te")
        print("  ‚úÖ Intervalles optimis√©s pour √©ducation")
        print("  üéì Parfait pour apprendre la s√©curit√© IoT !")
        
    else:
        # Configuration interactive
        print("üîß Lancement configuration interactive...")
        run_command("idf.py menuconfig")

def build_project():
    """Compile le projet Community avec optimisations √©ducatives"""
    print("üî® Compilation SecureIoT-VIF Community Edition...")
    
    start_time = time.time()
    run_command("idf.py build")
    build_time = time.time() - start_time
    
    print(f"‚úÖ Compilation termin√©e en {build_time:.1f}s")
    
    # Afficher les informations de build Community
    if os.path.exists("build/bootloader/bootloader.bin"):
        print("üìä Taille des binaires Community:")
        
        # Taille bootloader
        bootloader_size = os.path.getsize("build/bootloader/bootloader.bin")
        print(f"  üì¶ Bootloader: {bootloader_size:,} bytes")
        
        # Taille application
        app_files = ["build/SecureIoT-VIF-Community.bin"]
        for app_file in app_files:
            if os.path.exists(app_file):
                app_size = os.path.getsize(app_file)
                print(f"  üì¶ Application: {app_size:,} bytes")
                
        print("üí° Optimisations Community:")
        print("  üéì Taille r√©duite pour √©ducation")
        print("  üìö Fonctionnalit√©s de base seulement")
        print("  ‚ö° Compilation rapide pour it√©rations")

def flash_project(port):
    """Flash le firmware Community"""
    print(f"‚ö° Flash SecureIoT-VIF Community sur {port}...")
    
    start_time = time.time()
    run_command(f"idf.py -p {port} flash")
    flash_time = time.time() - start_time
    
    print(f"‚úÖ Flash termin√© en {flash_time:.1f}s")
    print("üéâ SecureIoT-VIF Community Edition d√©ploy√© !")
    
    # Instructions post-flash Community
    print("\nüìã Prochaines √©tapes:")
    print("  1Ô∏è‚É£ Lancer le monitoring: python tools/flash_tool_community.py monitor")
    print("  2Ô∏è‚É£ V√©rifier les logs crypto de base")
    print("  3Ô∏è‚É£ Confirmer la lecture DHT22")
    print("  4Ô∏è‚É£ Tester la d√©tection d'anomalies par seuils")
    print("\nüéì Version √©ducative parfaite pour apprendre !")

def monitor_project(port):
    """Monitor les logs Community avec affichage √©ducatif"""
    print(f"üì∫ Monitoring SecureIoT-VIF Community sur {port}...")
    print("üîç Recherchez ces logs de succ√®s Community:")
    print("  ‚úÖ 'D√©marrage SecureIoT-VIF Community Edition'")
    print("  ‚úÖ 'Crypto de base initialis√©'") 
    print("  ‚úÖ 'Version √©ducative - Crypto software seulement'")
    print("  ‚úÖ 'V√©rification int√©grit√© initiale r√©ussie'")
    print("  ‚úÖ 'Community Edition Op√©rationnel'")
    print("\nüí° Appuyez sur Ctrl+] pour quitter")
    
    run_command(f"idf.py -p {port} monitor")

def detect_port():
    """D√©tecte automatiquement le port s√©rie ESP32"""
    try:
        import serial.tools.list_ports
        
        ports = list(serial.tools.list_ports.comports())
        
        # Rechercher sp√©cifiquement ESP32
        esp32_ports = []
        for p in ports:
            desc_lower = p.description.lower()
            if any(keyword in desc_lower for keyword in ['cp210', 'ch340', 'ftdi', 'silicon labs', 'esp32']):
                esp32_ports.append(p.device)
        
        if esp32_ports:
            selected_port = esp32_ports[0]
            if len(esp32_ports) > 1:
                print(f"üîç {len(esp32_ports)} ports ESP32 d√©tect√©s:")
                for i, port in enumerate(esp32_ports):
                    print(f"  {i+1}. {port}")
                print(f"üìå S√©lection automatique: {selected_port}")
            return selected_port
        elif ports:
            return ports[0].device
        else:
            return "/dev/ttyUSB0"  # D√©faut Linux
            
    except ImportError:
        print("‚ö†Ô∏è pyserial non install√©, utilisation port par d√©faut")
        return "/dev/ttyUSB0"

def run_tests():
    """Ex√©cute les tests Community simplifi√©s"""
    print("üß™ Tests SecureIoT-VIF Community Edition...")
    
    # Tests de compilation Community
    print("üìã Test compilation Community...")
    start_time = time.time()
    run_command("idf.py build")
    build_time = time.time() - start_time
    print(f"‚úÖ Compilation r√©ussie en {build_time:.1f}s")
    
    # Tests de configuration Community
    print("üìã Test configuration Community...")
    if os.path.exists("sdkconfig"):
        with open("sdkconfig", "r") as f:
            config = f.read()
            
        # V√©rifier les configurations Community cl√©s
        community_configs = [
            "CONFIG_SECURE_IOT_COMMUNITY_EDITION=y",
            "CONFIG_SECURE_IOT_BASIC_CRYPTO_ONLY=y",
            "CONFIG_SECURE_BOOT=n",
            "CONFIG_SECURE_FLASH_ENC_ENABLED=n"
        ]
        
        missing_configs = []
        for config_item in community_configs:
            if config_item not in config:
                missing_configs.append(config_item)
        
        if missing_configs:
            print("‚ö†Ô∏è Configurations Community manquantes:")
            for config_item in missing_configs:
                print(f"  ‚ùå {config_item}")
        else:
            print("‚úÖ Configuration Community compl√®te")
    else:
        print("‚ùå Fichier sdkconfig manquant")
    
    # Test structure projet Community
    print("üìã Test structure projet Community...")
    community_files = [
        "components/secure_element/crypto_operations_basic.c",
        "components/secure_element/include/crypto_operations_basic.h", 
        "main/app_config.h"
    ]
    
    missing_files = []
    for file_path in community_files:
        if not os.path.exists(file_path):
            missing_files.append(file_path)
    
    if missing_files:
        print("‚ùå Fichiers Community manquants:")
        for file_path in missing_files:
            print(f"  ‚ùå {file_path}")
    else:
        print("‚úÖ Structure projet Community compl√®te")
    
    print("üéâ Tests Community termin√©s")

def clean_project():
    """Nettoie le projet Community"""
    print("üßπ Nettoyage SecureIoT-VIF Community...")
    
    run_command("idf.py clean")
    
    # Supprimer les fichiers temporaires Community
    temp_files = ["sdkconfig", "sdkconfig.old", "dependencies.lock"]
    for f in temp_files:
        if os.path.exists(f):
            os.remove(f)
            print(f"üóëÔ∏è Supprim√©: {f}")
    
    print("‚úÖ Nettoyage Community termin√©")

def show_version_info():
    """Affiche les informations de version Community"""
    print("üìã === Informations SecureIoT-VIF Community ===")
    
    # D√©tection version
    version = "Non d√©tect√©e"
    if os.path.exists("main/app_config.h"):
        with open("main/app_config.h", "r") as f:
            content = f.read()
            if "1.0.0-COMMUNITY" in content:
                version = "v1.0.0 - Community Edition üéì"
            elif "2.0.0-ESP32-CRYPTO" in content:
                version = "v2.0.0 - Enterprise Edition (Mauvais outil)"
    
    print(f"Version: {version}")
    
    # Afficher les fonctionnalit√©s Community
    if "Community" in version:
        print("\nüéì Fonctionnalit√©s Community Edition:")
        print("  üìö Id√©al pour apprentissage et √©ducation")
        print("  üîê Crypto de base (software mbedTLS)")
        print("  ‚úÖ V√©rification int√©grit√© au d√©marrage")
        print("  üéØ D√©tection anomalies par seuils fixes")
        print("  üå°Ô∏è Interface capteurs DHT22 compl√®te")
        print("  üìä Statistiques et monitoring basiques")
        
        print("\nüéØ Usage Recommand√©:")
        print("  üéì √âtudiants en cybers√©curit√©")
        print("  üë®‚Äçüè´ Enseignants et formateurs")
        print("  üî¨ Chercheurs acad√©miques")
        print("  üõ†Ô∏è Prototypage et exp√©rimentation")
        
        print("\nüö´ Limitations Community:")
        print("  ‚ùå Pas de crypto hardware (HSM, TRNG)")
        print("  ‚ùå Pas de v√©rification temps r√©el")
        print("  ‚ùå Pas d'attestation continue")
        print("  ‚ùå Pas de ML adaptatif")
        print("  ‚ùå Usage commercial interdit")

def main():
    parser = argparse.ArgumentParser(description="Outil de d√©veloppement SecureIoT-VIF Community Edition")
    parser.add_argument("action", 
                        choices=["build", "flash", "monitor", "all", "config", "test", "clean", "info"],
                        help="Action √† ex√©cuter")
    parser.add_argument("-p", "--port", help="Port s√©rie (auto-d√©tection si non sp√©cifi√©)")
    parser.add_argument("--auto-config", action="store_true", 
                        help="Configuration automatique Community (optimis√©e √©ducation)")
    parser.add_argument("--auto-port", action="store_true",
                        help="D√©tection automatique du port ESP32")
    
    args = parser.parse_args()
    
    # Banner Community
    print("üéì ===============================================")
    print("üìö SecureIoT-VIF Community Edition")
    print("üéØ Version √©ducative pour apprentissage")
    print("üí° Parfait pour √©tudiants et chercheurs")
    print("üöÄ D√©marrage en 5 minutes")
    print("üéì ===============================================\n")
    
    # V√©rifier l'environnement
    check_environment()
    
    # D√©tecter le port si demand√© ou non sp√©cifi√©
    if args.auto_port or not args.port:
        args.port = detect_port()
        print(f"üîç Port ESP32 d√©tect√©: {args.port}")
    
    # Ex√©cuter l'action demand√©e
    try:
        if args.action == "info":
            show_version_info()
        elif args.action == "config":
            configure_project(args)
        elif args.action == "build":
            build_project()
        elif args.action == "flash":
            build_project()
            flash_project(args.port)
        elif args.action == "monitor":
            monitor_project(args.port)
        elif args.action == "all":
            configure_project(args)
            build_project()
            flash_project(args.port)
            print("\n‚è≥ Attente 3s avant monitoring...")
            time.sleep(3)
            monitor_project(args.port)
        elif args.action == "test":
            run_tests()
        elif args.action == "clean":
            clean_project()
        
    except KeyboardInterrupt:
        print("\nüõë Op√©ration interrompue par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()